<title>HotNet2 Subnetworks</title>
<style>
	body{
		font-family:"Helvetica","Arial";
		padding:10px;
	}
	div.container{
		width:70%;
		margin:0px auto;
		background:"#F6F6F6";
	}
	div#instructions{
		width:45%;
		float:left;
	}
	div#filters{
		width:45%;
		float:right;
	}
	div#figures{
		padding:5px;
		clear:both;
	}
	div#figures h3 small#stats{
		float:right;
		font-size:80%;
	}
	hr{
		clear:both;
		padding-bottom:0px;
		margin:0px;
		border:0;
		border-bottom:1px solid #eee;
	}
	div#figures hr{
		margin-top:30px;
		border:0;
		border-bottom:1px dashed #777777;
	}
	abbr{
		font-weight:bold;
		color:rgb(36,64,144);
		border:1px solid rgb(36,64,144);
		cursor:help;
		font-size:80%;
		padding:0px 2px 0px 2px;
		float:right;
		margin-left:30px;
	}
</style>
<body>
<div class="container">
	<h1>HotNet2 Results</h1>
	<hr/>
	<div style="border-bottom:1px solid #eee;padding-bottom:10px">
		<div id="instructions">
			<h3>Instructions</h3>
			This page shows the protein interactions among each subnetwork identified by HotNet2.
			You can toggle the interaction networks shown by clicking them in the legend,
			and you can reposition the nodes in the subnetwork for a better view by dragging/dropping them.
		</div>
		<div id="filters">
			<h3>Parameters</h3>
			<table>
				<tr>
					<td><label>Minimum edge weight &delta;</label>:</td>
					<td>
						<select id="deltas"></select>
						<abbr title="Changing delta changes the subnetworks and significance reported by HotNet2.">?</abbr>
					</td>
				</tr>
				<tr>
					<td><label>Minimum subnetwork size <i>k</i></label>:</td>
					<td>
						<input type="range" id="k" min="2" value="2" max="10" step="1" />
						<span id="k">2</span>
						<abbr title="Hide subnetworks of size less than k.">?</abbr>
					</td>
				</tr>
			</table>
		</div>
		<br style="clear:both"/>
	</div>
	<div id="figures">
		<h3>
			Subnetworks <small></small>
			<small id="stats">
				<span id="observed"></span>
				<span id="expected"></span>
				<span id="pval"></span>
			</small>
		</h3>
	</div>
</div>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
var heatFormat = d3.format(".3r");
function subnetwork(params) {
  var params = params || {},
	  style  = params.style || {},
	  colorSchemes = style.colorSchemes || {};

  var cold = style.cold || 'rgb(102, 178, 255)',
	  edgeWidth = style.edgeWidth || 1.5,
	  fontColor = style.fontColor || '#333',
	  fontFamily = style.fontFamily || '"Helvetica","Arial"',
	  fontSize = style.fontSize || 10,
	  heatLegendHeight = style.heatLegendHeight || 30,
	  heatLegendWidth = style.heatLegendWidth ||  100,
	  height = style.height || 200,
	  hot = style.hot || 'rgb(255, 51, 51)',
	  margins = style.margins || {bottom: 0, left: 0, right: 0, top: 0},
	  netLegendBox = style.netLegendBox || 15,
	  netLegendWidth = style.netLegendWidth || 200,
	  nodeRadius = style.nodeRadius || 10,
	  transitionTime = style.transitionTime || 500,
	  width = style.width || 350;

  var showNetworkLegend = false,
	  showGradientLegend = false;

  function chart(selection) {
	selection.each(function(data) {
	  //////////////////////////////////////////////////////////////////////////
	  // General setup
	  var edges = data.edges,
		  nodes = data.nodes;

	  // Select the svg element, if it exists.
	  var fig = d3.select(this)
		  .selectAll('svg')
		  .data([data])
		  .enter()
			.append('svg');

	  fig.attr('id', 'figure')
		  .attr('height', height + margins.top + margins.bottom)
		  .attr('width', width)
		  .style('font-family', fontFamily)
		  .style('font-size', fontSize);

	  // Create the color scale
	  var heatRange = nodes.map(function(n){ return n.heat; }),
		  color = d3.scale.linear()
			  .domain([d3.min(heatRange), d3.max(heatRange)])
			  .range([cold, hot])
			  .nice();

	  // Set up the force directed graph
	  var force = d3.layout.force()
		  .charge(-400)
		  .linkDistance(40)
		  .size([width, height]);

	  // This drag function fixes nodes in place once they are dragged
	  var drag = force.drag().on('dragstart', function(d) {
		d.fixed = true;
		d3.select(this).select('circle').style('stroke-opacity', 0);
	  });

	  // Set up scales
	  var x = d3.scale.linear().range([0, width]),
		  y = d3.scale.linear().range([0, height]);

	  var links = loadLinks(edges, nodes);

	  force.nodes(nodes)
		  .links(links)
		  .start();

	  // Determine which networks are in the data
	  var networks = [];
	  for (var i = 0; i < links.length; i++) {
		for (var j = 0; j < links[i].networks.length; j++) {
		  if (networks.indexOf(links[i].networks[j]) == -1) {
			networks.push(links[i].networks[j]);
		  }
		}
	  }

	  var numNets = networks.length,
		  netLegendHeight = numNets * 10;

	  // Make sure each network has a color
	  if (colorSchemes.network == undefined) {
		var colors = d3.scale.category20();
		colorSchemes.network = {};
		for (var i = 0; i < networks.length; i++) {
		  colorSchemes.network[networks[i]] = colors(i);
		}
	  }

	  // Draw the edges
	  var link = fig.selectAll('.link')
		  .data(links);

	  var linkInNetwork = {},
		  activeNetworks = {};

	  for (var i = 0; i < networks.length; i++) {
		var net = networks[i],
			netColor = colorSchemes.network[networks[i]];
			activeNetworks[net] = true;

			var inNet = fig.selectAll('.' + net)
				.data(links.filter(function (link) {
				  return link.networks && link.networks.indexOf(net) != -1;
				}))
				.enter()
				.append('line')
				  .classed(net, true)
				  .style('stroke-width', edgeWidth)
				  .style('stroke', netColor);

			linkInNetwork[net] = inNet;
	  }

	  // Draw the nodes
	  // Keep the circles and text in the same group for better dragging
	  var circle = fig.append('svg:g')
		  .selectAll('node')
		  .data(nodes)
		  .enter()
		  .append('svg:g')
			.style('cursor', 'move')
			.call(force.drag)
			.on('dblclick', function(d) {
			  d.fixed = d.fixed ? false : true;
			  d3.select(this).select('circle').style('stroke-opacity', 1);
			});

	  circle.append('circle')
		  .attr('r', nodeRadius)
		  .attr('fill', function(d) { return color(d.heat); })
		  .style('stroke-width', 1.5)
		  .style('stroke', '#333');

	  circle.append('text')
		  .attr('x', nodeRadius)
		  .attr('y', '.31em')
		  .style('fill', fontColor)
		  .style('font-size', fontSize)
		  .text(function(d) { return d.name; });

	  // Make sure nodes don't go outside the borders of the SVG
	  force.on('tick', function() {
		circle.attr('transform', function(d) {
		  d.x = Math.max(nodeRadius, Math.min(width - nodeRadius, d.x));
		  d.y = Math.max(nodeRadius, Math.min(height - nodeRadius, d.y));
		  return 'translate(' + d.x + ',' + d.y + ')';
		});

		networks.forEach(function(net, i) {
		  var offset = edgeWidth * (i = numNets / 2);
		  linkInNetwork[net]
			  .attr('x1', function(d) { return d.source.x + offset; })
			  .attr('y1', function(d) { return d.source.y + offset; })
			  .attr('x2', function(d) { return d.target.x + offset; })
			  .attr('y2', function(d) { return d.target.y + offset; });
		});
	  }); // end force

	  //////////////////////////////////////////////////////////////////////////
	  // DRAW LEGENDS
	  function renderNetworkLegend() {
		var netLegend = fig.selectAll(".net-group")
			.data(networks).enter()
			.append("g")
				.style("font-size", 12)
				.on("click", function(n){
					var active = activeNetworks[n];
					activeNetworks[n] = !active;
					linkInNetwork[n].transition().duration(transitionTime)
						.style("stroke-opacity", active ? 0 : 1);

					d3.select(this).transition().duration(transitionTime)
						.style("stroke-opacity", active ? 0.5 : 1)
						.style("fill-opacity", active ? 0.5 : 1);
				});

		netLegend.append("line")
			.attr("x1", 0)
			.attr("x2", netLegendBox)
			.style("stroke-width", edgeWidth)
			.style("stroke", function(n){ return colorSchemes.network[n]; });

		netLegend.append("text")
			.attr("x", 8 + netLegendBox)
			.attr("y", 3)
			.text(function(n){ return n; });

		netLegend.attr("transform", function(d, i){
			return "translate(" + (width-d3.select(this).node().getBBox().width) + "," + ((i+1)*netLegendBox) + ")";
		})

	  } // end renderNetworkLegend()


	  function renderGradientLegend() {
		var heatLegend = selection.append('div')
			.attr('id', 'subnetwork-legend')
			.style('width', heatLegendWidth + 'px');

		var gradient = heatLegend.append('svg')
			.attr('width', heatLegendWidth)
			.attr('height', heatLegendHeight);

		gradient.append('svg:defs')
			.append('svg:linearGradient')
			  .attr('x1', '0%')
			  .attr('y1', '0%')
			  .attr('x2', '100%')
			  .attr('y2', '0%')
			  .attr('id', 'heat_gradient')
			  .call(function (gradient) {
				gradient.append('svg:stop')
				  .attr('offset', '0%')
				  .attr('style', 'stop-color:' + cold + ';stop-opacity:1');
				gradient.append('svg:stop')
				  .attr('offset', '100%')
				  .attr('style', 'stop-color:' + hot + ';stop-opacity:1');
			  });

		gradient.append('rect')
			.attr('width', heatLegendWidth)
			.attr('height', heatLegendHeight)
			.style('fill', 'url(#heat_gradient)');

		var labels = heatLegend.append('div')
			.style('clear', 'both');
		var format = d3.format("g");

		heatLegend.append('span')
		  .style('float', 'left')
		  .text(heatFormat(d3.min(heatRange)));

		heatLegend.append('span')
		  .style('float', 'right')
		  .text(heatFormat(d3.max(heatRange)));
	  } // end renderGradientLegend()


	  if(showNetworkLegend) {
		renderNetworkLegend();
	  }
	  if(showGradientLegend) {
		renderGradientLegend();
	  }


	  //////////////////////////////////////////////////////////////////////////
	  // UTILITY FUNCTIONS
	  // Returns list of links between a given set of nodes and an edge list
	  function loadLinks(edges, nodes) {
		var links = [];

		for (var i = 0; i < nodes.length; i++) {
		  var u = nodes[i].name;
		  for(var j = 0; j < nodes.length; j++) {
			var v = nodes[j].name;
			for (var k = 0; k < edges.length; k++) {
			  var src = edges[k].source,
				  tgt = edges[k].target;
			  if ( (u == src && v == tgt) || (u == tgt && v == src) ) {
				links.push({
				  'source': nodes[i],
				  'target': nodes[j],
				  'weight': edges[k].weight,
				  'networks': edges[k].networks
				})
			  }
			}
		  }
		}

		return links;
	  } // end loadLinks()
	});
  } // end chart()


  chart.addNetworkLegend = function () {
	showNetworkLegend = true;
	return chart;
  }

  chart.addGradientLegend = function () {
	showGradientLegend = true;
	return chart;
  }



  return chart;
}
// Add the subnetworks 
d3.json('subnetworks.json', function(json) {
	// Populate the delta select and the ks slider
	var deltaSelect = d3.select("div#filters select");
	deltaSelect.selectAll(".delta")
		.data(json.deltas.sort()).enter()
		.append("option")
		.attr("value", function(d){ return d; })
		.text(function(d){ return d; })

	var kSlider = d3.select("div#filters input")
		.attr("min", d3.min(json.ks))
		.attr("max", d3.max(json.ks));

	// Add listeners to the deltaSelect and kSlider
	deltaSelect.on("change", drawSubnetworks);
	kSlider.on("change", filterSubnetworks);

	var delta = json.deltas[0],
		fig = d3.select("#figures");
	function drawSubnetworks(){
		// Retrieve the current delta
		if (d3.select(this).node().value){
			delta = d3.select(this).node().value;
		}

		// Remove the old subnetworks
		fig.selectAll("div").remove();

		// Update the title to reflect the new subnetworks and significance
		d3.select("div#figures h3 small").html("&delta; = " + delta);

		// Create an object that contains any changes to the default styles 
		var styling = {
			fontColor: '#34495E',
			heatLegendWidth: 350,
			netLegendWidth: 90
		}

		// Add each subnetwork as an SVG wrapped in a div
		json.subnetworks[delta].forEach(function(d){
			fig.append("div")
				.datum(d)
				.attr("class", function(d){ return "subnetwork k" + d.nodes.length; })
				.call(
					subnetwork({style: styling})
						.addNetworkLegend()
						.addGradientLegend()
		  		)
		  		.append("hr");

		});
		filterSubnetworks();
	} // end drawSubnetworks

	var stats = d3.select("div#figures h3 small#stats");
	function filterSubnetworks(){
		// Get the current value of k from the slider
		var k = kSlider.node().value;

		// Update the slider value, and update the signficance
		d3.select("span#k").text(k);
		console.log(delta)
		stats.select("span#pval").html("P=" + json.stats[delta][k].pval);
		stats.select("span#expected").html("Expected: " + json.stats[delta][k].expected);
		stats.select("span#observed").html("Observed: " + json.stats[delta][k].observed);

		// Show subnetworks of size at least k, hide the rest
		d3.selectAll("div.subnetwork").style("display", "inline");
		d3.range(d3.min(json.ks), k).forEach(function(k){
			d3.selectAll(".k" + k).style("display", "none");
		});
	}

	// Draw the subnetworks, starting with the first delta
	drawSubnetworks();

});
</script>
